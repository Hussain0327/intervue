"""ElevenLabs streaming Text-to-Speech client."""

import base64
import logging
import time
from collections.abc import AsyncIterator
from dataclasses import dataclass
from typing import TYPE_CHECKING

from app.core.config import get_settings

if TYPE_CHECKING:
    from elevenlabs.client import AsyncElevenLabs

logger = logging.getLogger(__name__)


@dataclass
class TTSResult:
    """Result from text-to-speech synthesis."""

    audio_base64: str
    audio_bytes: bytes
    format: str
    latency_ms: int


class ElevenLabsStreamingTTS:
    """ElevenLabs streaming text-to-speech client.

    Supports both streaming synthesis with text input streaming
    and batch synthesis for backward compatibility.
    """

    def __init__(self) -> None:
        settings = get_settings()
        self.api_key = settings.elevenlabs_api_key
        self.voice_id = settings.elevenlabs_voice_id
        self.model_id = settings.elevenlabs_model_id
        self.timeout = settings.tts_timeout
        self._client: "AsyncElevenLabs | None" = None

    @property
    def client(self) -> "AsyncElevenLabs":
        """Lazy initialization of ElevenLabs client."""
        if self._client is None:
            from elevenlabs.client import AsyncElevenLabs

            self._client = AsyncElevenLabs(api_key=self.api_key)
        return self._client

    async def synthesize_stream(
        self,
        text_stream: AsyncIterator[str],
    ) -> AsyncIterator[bytes]:
        """Stream text in, stream audio out.

        Uses ElevenLabs text-to-speech streaming API to convert
        a stream of text chunks into a stream of audio chunks.

        Args:
            text_stream: Async iterator yielding text chunks (sentences)

        Yields:
            Audio chunks as bytes (MP3 format)
        """
        from elevenlabs import VoiceSettings

        # Collect text chunks into sentences for streaming
        async for text_chunk in text_stream:
            if not text_chunk.strip():
                continue

            # Use the streaming API for each sentence
            async for audio_chunk in self.client.text_to_speech.convert_as_stream(
                voice_id=self.voice_id,
                text=text_chunk,
                model_id=self.model_id,
                output_format="mp3_44100_128",
                voice_settings=VoiceSettings(
                    stability=0.5,
                    similarity_boost=0.75,
                    style=0.0,
                    use_speaker_boost=True,
                ),
            ):
                yield audio_chunk

    async def synthesize_stream_realtime(
        self,
        text_stream: AsyncIterator[str],
    ) -> AsyncIterator[bytes]:
        """Real-time streaming with websocket for lowest latency.

        Uses ElevenLabs websocket streaming for real-time text-to-speech
        with the lowest possible latency. Text is streamed in as it's
        generated by the LLM.

        Args:
            text_stream: Async iterator yielding text tokens

        Yields:
            Audio chunks as bytes
        """
        import asyncio

        from elevenlabs import VoiceSettings

        # Buffer for collecting text
        text_buffer = ""
        audio_queue: asyncio.Queue[bytes | None] = asyncio.Queue()

        async def stream_text():
            """Stream text to ElevenLabs."""
            nonlocal text_buffer
            async for chunk in text_stream:
                text_buffer += chunk

        async def process_audio():
            """Process complete text and yield audio."""
            # Wait a bit for text to accumulate
            await asyncio.sleep(0.1)

            # Stream the accumulated text
            async for audio_chunk in self.client.text_to_speech.convert_as_stream(
                voice_id=self.voice_id,
                text=text_buffer,
                model_id=self.model_id,
                output_format="mp3_44100_128",
                voice_settings=VoiceSettings(
                    stability=0.5,
                    similarity_boost=0.75,
                    style=0.0,
                    use_speaker_boost=True,
                ),
            ):
                await audio_queue.put(audio_chunk)
            await audio_queue.put(None)

        # Start streaming text in background
        text_task = asyncio.create_task(stream_text())

        # Wait for text to be collected
        await text_task

        # Process and yield audio
        audio_task = asyncio.create_task(process_audio())

        while True:
            chunk = await audio_queue.get()
            if chunk is None:
                break
            yield chunk

        await audio_task

    async def synthesize(self, text: str, voice: str | None = None) -> TTSResult:
        """Synthesize speech from text (batch mode for backward compatibility).

        Args:
            text: Text to synthesize
            voice: Voice ID (optional, uses default if not provided)

        Returns:
            TTSResult with audio data and metadata
        """
        from elevenlabs import VoiceSettings

        start_time = time.perf_counter()
        voice_id = voice or self.voice_id

        # Collect all audio chunks
        audio_chunks: list[bytes] = []

        async for chunk in self.client.text_to_speech.convert_as_stream(
            voice_id=voice_id,
            text=text,
            model_id=self.model_id,
            output_format="mp3_44100_128",
            voice_settings=VoiceSettings(
                stability=0.5,
                similarity_boost=0.75,
                style=0.0,
                use_speaker_boost=True,
            ),
        ):
            audio_chunks.append(chunk)

        audio_bytes = b"".join(audio_chunks)
        audio_base64 = base64.b64encode(audio_bytes).decode("utf-8")

        latency_ms = int((time.perf_counter() - start_time) * 1000)

        return TTSResult(
            audio_base64=audio_base64,
            audio_bytes=audio_bytes,
            format="mp3",
            latency_ms=latency_ms,
        )


_elevenlabs_client: ElevenLabsStreamingTTS | None = None


def get_elevenlabs_client() -> ElevenLabsStreamingTTS:
    """Get or create the ElevenLabs TTS client."""
    global _elevenlabs_client
    if _elevenlabs_client is None:
        _elevenlabs_client = ElevenLabsStreamingTTS()
    return _elevenlabs_client
